using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using CloudSync.Modules.UserManagement.Repositories.Interfaces;
using CloudSync.Modules.UserManagement.Services.Exceptions;
using CloudSync.Modules.UserManagement.Services.Interfaces;
using Microsoft.IdentityModel.Tokens;
using Google.Apis.Auth;
using Shared.Enums.UserManagement;
using Shared.Requests.UserManagement;
using Shared.Responses.UserManagement;

namespace CloudSync.Modules.UserManagement.Services;

public class AuthService(IConfiguration configuration, IInvitedUserRepository invitedUserRepository) : IAuthService
{
    private readonly IConfigurationSection _jwtSettings = configuration.GetSection("JWT");

    public async Task<GoogleLoginResponse> LoginAsync(GoogleLoginRequest request)
    {
        var payload = await ValidateIdToken(request);

        // TODO Check if user already exists
        var existingUser = await userRepository.GetByGoogleUserIdAsync(payload.Subject);

        if (existingUser != null)
        {
            return await LoginExistingUserAsync(existingUser);
        }
        
        var existingInvitee = await invitedUserRepository.GetByEmailAsync(payload.Email);
        
        if (existingInvitee == null)
        {
            throw new AuthException("User has not been invited.", 404);
        }

        return Enum.Parse<InvitedUserStatus>(existingInvitee.Status) switch
        {
            InvitedUserStatus.Accepted => throw new AuthException("User has already accepted invitation."),
            InvitedUserStatus.Expired => throw new AuthException("Invitation has expired."),
            InvitedUserStatus.Pending => new GoogleLoginResponse
            {
                JsonWebToken = GenerateJwt(payload.Email),
                // TODO return user
            },
            _ => throw new AuthException("Error logging in or creating new user.", 500)
        };
    }

    private async Task<GoogleLoginResponse> LoginExistingUserAsync(User existingUser)
    {
        var existingUserResponse = new UserResponse
        {
            Id = existingUser.Id,
            Email = existingUser.Email,
            CreateDateTime = existingUser.CreateDateTime,
            LastLoginDateTime = DateTime.UtcNow,
            UserSettings = existingUser.UserSettings
        };

        await userRepository.UpdateLastLoginTimeAsync(existingUser.Id);

        return new GoogleLoginResponse
        {
            JsonWebToken = GenerateJwt(existingUser.Email),
            User = existingUserResponse
        };
    }


    // Accepts an ID token generated by the frontend login process when a client successfully logins in with their
    // Google account. This tests the ID token against the Google Auth API and returns data about a user's Google account.
    // Returned data includes the Full Name, First and Last Name, Email, Subject (Google User ID string), the time the
    // token was issued at, time before expiration, and information about the Audience, Issuer, and Authorized party.
    private async Task<GoogleJsonWebSignature.Payload> ValidateIdToken(GoogleLoginRequest request)
    {
        if (string.IsNullOrWhiteSpace(request.IdToken))
        {
            throw new AuthException("Missing ID token.");
        }

        try
        {
            var settings = new GoogleJsonWebSignature.ValidationSettings
            {
                Audience = [_jwtSettings["Audience"]]
            };

            return await GoogleJsonWebSignature.ValidateAsync(request.IdToken, settings);
        }
        catch (InvalidJwtException e) when (e.Message.Contains("expired"))
        {
            throw new AuthException("Google ID token has expired.", 401);
        }
        catch (InvalidJwtException)
        {
            throw new AuthException("Invalid Google id token", 401);
        }
    }

    private string GenerateJwt(string email)
    {
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings["Key"] ?? throw new AuthException("Jwt key not found or missing.", 500)));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        
        var token = new JwtSecurityToken(
            issuer: _jwtSettings["Issuer"],
            audience: _jwtSettings["Audience"],
            claims: [new Claim(ClaimTypes.Name, email)],
            expires: DateTime.UtcNow.AddMinutes(double.Parse(_jwtSettings["ExpiresInMinutes"] ?? throw new AuthException("Jwt key not found or missing.", 500))),
            signingCredentials: creds
        );
            
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}